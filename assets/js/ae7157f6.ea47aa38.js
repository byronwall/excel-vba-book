"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[5058],{3905:function(e,t,a){a.d(t,{Zo:function(){return u},kt:function(){return f}});var o=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function n(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,o)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?n(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,o,i=function(e,t){if(null==e)return{};var a,o,i={},n=Object.keys(e);for(o=0;o<n.length;o++)a=n[o],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(o=0;o<n.length;o++)a=n[o],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=o.createContext({}),h=function(e){var t=o.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},u=function(e){var t=h(e.components);return o.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var a=e.components,i=e.mdxType,n=e.originalType,l=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),d=h(a),f=i,p=d["".concat(l,".").concat(f)]||d[f]||c[f]||n;return a?o.createElement(p,s(s({ref:t},u),{},{components:a})):o.createElement(p,s({ref:t},u))}));function f(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var n=a.length,s=new Array(n);s[0]=d;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var h=2;h<n;h++)s[h]=a[h];return o.createElement.apply(null,s)}return o.createElement.apply(null,a)}d.displayName="MDXCreateElement"},6802:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return r},contentTitle:function(){return l},metadata:function(){return h},toc:function(){return u},default:function(){return d}});var o=a(7462),i=a(3366),n=(a(7294),a(3905)),s=["components"],r={},l=void 0,h={unversionedId:"overview-of-UDFs/13-04 limitations-of-UDfs",id:"overview-of-UDFs/13-04 limitations-of-UDfs",title:"13-04 limitations-of-UDfs",description:"limitations of UDfs",source:"@site/docs/13-overview-of-UDFs/13-04 limitations-of-UDfs.md",sourceDirName:"13-overview-of-UDFs",slug:"/overview-of-UDFs/13-04 limitations-of-UDfs",permalink:"/excel-vba-book/docs/overview-of-UDFs/13-04 limitations-of-UDfs",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/13-overview-of-UDFs/13-04 limitations-of-UDfs.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"13-03 some-simple-UDFs",permalink:"/excel-vba-book/docs/overview-of-UDFs/13-03 some-simple-UDFs"},next:{title:"13-05 managing-the-parameters-and-types-of-UDFs",permalink:"/excel-vba-book/docs/overview-of-UDFs/13-05 managing-the-parameters-and-types-of-UDFs"}},u=[{value:"limitations of UDfs",id:"limitations-of-udfs",children:[{value:"no side effects",id:"no-side-effects",children:[],level:3},{value:"when does a UDF update",id:"when-does-a-udf-update",children:[],level:3},{value:"using Application.Volatile",id:"using-applicationvolatile",children:[],level:3},{value:"beware of global variables",id:"beware-of-global-variables",children:[],level:3},{value:"beware of UDFs in addins",id:"beware-of-udfs-in-addins",children:[],level:3},{value:"debugging UDFs is different",id:"debugging-udfs-is-different",children:[],level:3}],level:2}],c={toc:u};function d(e){var t=e.components,a=(0,i.Z)(e,s);return(0,n.kt)("wrapper",(0,o.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h2",{id:"limitations-of-udfs"},"limitations of UDfs"),(0,n.kt)("p",null,"This section will focus on the aspects of UDFs where you are limited. There are couple of key things to remember here:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"A UDF is not allowed to change the Workbook, Worksheet, or a Range -- no side effects are allowed"),(0,n.kt)("li",{parentName:"ul"},"A UDF will only update if the cells it refers to change"),(0,n.kt)("li",{parentName:"ul"},"You can mark a UDF as Volatile, but this may create other problems (namely speed)"),(0,n.kt)("li",{parentName:"ul"},"UDFs are allowed to use global variables but you can wreck this process by having errors while they execute"),(0,n.kt)("li",{parentName:"ul"},"UDFs inside an addin can pollute a spreadsheet that might be used by someone without that addin"),(0,n.kt)("li",{parentName:"ul"},"You can debug a UDF but not by using the Evaluate Formula option that might be familiar to more people")),(0,n.kt)("h3",{id:"no-side-effects"},"no side effects"),(0,n.kt)("p",null,"The biggest temptation of a UDF is one of the few things that is not allowed -- you are not allowed to have a side effect from a UDF. This generally comes up when you want to change something about the Range that the UDF is referring to or being called from. You think: \"I'd just love to color this cell red if the UDF detects some state while executing\". This thought comes up because it'd be nice to have the UDF update when called and even better if you can avoid dealing with conditional formatting. Alas, this is not allowed. The UDF must execute without making a change to the spreadsheet. This generally makes sense if you think about how Excel goes about calculating the spreadsheet. It makes a map of how cells are related and then proceeds to calculate the values in an order where each cell that depends on another is calculated in the precise order that is required. This process allows Excel to complete as fast as possible, without errors, and while using as many CPU cores as possible. If your UDF is able to change the spreadsheet after Excel has determine the order of calculations, then it becomes impossible to ensure that the spreadsheet is still correct. Because of this, Excel does not allow sde effects from a UDF."),(0,n.kt)("p",null,"The other aspect of this limitation that comes up often enough in practice is hat you cannot use a Worksheet function that modifies the spreadsheet even if you intend to undo that function. For example: I have attempted to use the AutoFilter inside a UDF in order to determine how many times some condition showed up in a table. This is not allowed even though I intended to undo the AutoFilter before returning from my UDF. This limitation also applies to Copy/Paste and other common functions."),(0,n.kt)("h3",{id:"when-does-a-udf-update"},"when does a UDF update"),(0,n.kt)("p",null,"The next limitation to consider is that a UDF will only update when the Ranges it refers to are changed. This is related to the dependency tree described above. Excel will only call your UDF if one of the cells that it directly depends on it is updated. This is important because you have access to the entire Workbook inside a UDF so you can create a situation where your UDF ",(0,n.kt)("em",{parentName:"p"},"should")," update something, but it doesn't because it does not know that it should have been updated. This si discussed later, but the quick way around this limit is to mark your UDF as Volatile. See the warnings later related to this."),(0,n.kt)("p",null,"A common example of when this sort of issue pops up is when you are using a reference to a Range inside the UDF that is computed only inside the UDF. For example, you want to do some statistics for a single Range that are dependent on a larger Range of data. You can write a UDF that takes the single cell as a parameter but then compute the larger Range inside the UDF without having to refer to it. Maybe that larger Range is a mess via normal Excel so you've skipped that step. Well, be aware that your UDF will only calculate for the even cell if the cell it refers to changes. This means that the larger group may change -- and invalidate your current result -- but if the single cell stays the same, then your UDF will not update that cell."),(0,n.kt)("p",null,"This same issue pops up if you are using properties of the Range that are not a part of the calculation model for Excel. That is, there are some changes which will not trigger a recalculation from Excel. These are typically related to using the formatting of a cell in a UDF. A very common example is returning the Range.Text from a UDF so that you can get the value exactly as it is displayed in the spreadsheet. If you change the format of the cell, you are not guaranteed to have the UDF called updating your UDF value."),(0,n.kt)("h3",{id:"using-applicationvolatile"},"using Application.Volatile"),(0,n.kt)("p",null,"Mentioned above, there is one surefire way to ensure that your UDF will be called whenever there is a change anywhere on the spreadsheet: mark the function as Volatile. This is done by calling Application.Volatile somewhere in your UDF. TODO: is this right? Once you have made this call, your UDF will be called anytime a calculation is done. This also means that anything that depends on your cell will be recalculated every time. There is a huge upside to using Volatile UDFs in certain instance: you are guaranteed that they represent the correct value. THe downside is that your UDF is being called constantly which means that if it is slow, your entire spreadsheet will be slow. If your UDF is littered across 10,000 cells, it will be run 10,000 times even if only a single cell changed. It is easy to underestimated how much this can slow down a Workbook. Having said that, sometimes speed is not a factor and you just want things to eb correct."),(0,n.kt)("p",null,"There are other functions (INDIRECT and OFFSET are the main ones) in Excel that are volatile, so it is not some awful thing to do necessarily. You should mark something as Volatile however only as a last resort or possibly as a first resort if you're just punching something out."),(0,n.kt)("p",null,"To avoid using Volatile, you may be able to have your UDF take an additional parameter to ensure that it is on the calculation chain of all the cells it depends on. Note: you don't actually have to use the parameters for anything, but if they appear in the UDF call, it will force Excel's calculation tree. Continuing with the statistic example from above, if you know that all of the data that could change is in columns B and C, you can simple send B:C in as a parameter to the UDF. This ensures that a change in those columns will force the UDF to call. You can then continue to compute the Range using your more complicated logic. This is somewhat wasteful and means you have extra parameters which don't do anything, but it can be a cleaner (and faster) solution than using Volatile."),(0,n.kt)("h3",{id:"beware-of-global-variables"},"beware of global variables"),(0,n.kt)("p",null,"VBA allows you to declare a variable outside of any Sub or Function definition. These are typically called global variables because they can be accessed from any code. This means that you can create some variables in a Sub and then use them in subsequent UDF calls. A good example is loading up a database of information and then using that information inside the UDF. This can be nice because then you do not have to load the data every time you call the UDF. I've used this effectively when doing unit conversions with UDFs."),(0,n.kt)("p",null,"The downside to this approach is that it seems to be relatively easy to corrupt those global variables if you have errors while the UDF runs. I've had it happen where that loaded database becomes corrupted somehow and then all of the dependent cells start to fail when their UDF is called. This type of error can be quite difficult to track down because it may not be obvious why the variable was corrupted."),(0,n.kt)("h3",{id:"beware-of-udfs-in-addins"},"beware of UDFs in addins"),(0,n.kt)("p",null,'A personal addin is a great way to organize helper code without constantly created macro enabled files to use the code. For Subs this works great because there is no lasting trace that a Sub was run, at least in terms of code in the file. For a UDF however, your UDF call will be a part of the spreadsheet. This does not force the spreadsheet to be a macro enabled one -- which is great -- but it does mean that anyone using the spreadsheet needs access to the UDF code. This creates a problem when you get comfortable using UDFs in an addin but then save the workbook with them in there. You have effectively "polluted" the workbook with addin UDF names which may or may not be available to others. This is fine if the addin truly is critical to the workbook, but it can create a mess for others if you\'re using UDFs for your own help and make a spreadsheet that others cannot use.'),(0,n.kt)("p",null,"The solution to this problem is to simply save the UDF as a Module in the spreadsheet, but this requires you to save the Workbook as macro enabled."),(0,n.kt)("p",null,"A rule I like to follow is simply: if I know that a UDF is required for the spreadsheet and that UDF is currently in an addin, I force myself to move the code into the Workbook and save as macro enabled. This can be a pain, but it's all too common that a Workbook is saved with a UDF from an addin, that addin changes or becomes unavailable, and now your Workbook is broken. It's best to avoid this scenario especially if you work with others who are not macro savvy."),(0,n.kt)("h3",{id:"debugging-udfs-is-different"},"debugging UDFs is different"),(0,n.kt)("p",null,"Most folks are familiar with the \"Evaluate Function\" feature of Excel which will help you walk through a function's evaluation in the order that Excel evaluates things. This can be incredibly helpful for array formulas where it's not always obvious the order Excel will do things in. Your UDF will also be evaluated in that feature, but it will not step through the logic of your UDF. This might seem obvious, but it's worth mentioning. IF you want to debug the logic of your addin, you need to set a breakpoint and actually debug the code. See the later section on this for the details."),(0,n.kt)("p",null,"TODO: add link to that section"))}d.isMDXComponent=!0}}]);