"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[225],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return c}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),h=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=h(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),p=h(n),c=i,m=p["".concat(s,".").concat(c)]||p[c]||u[c]||o;return n?a.createElement(m,l(l({ref:t},d),{},{components:n})):a.createElement(m,l({ref:t},d))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,l=new Array(o);l[0]=p;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:i,l[1]=r;for(var h=2;h<o;h++)l[h]=n[h];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},3998:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return s},metadata:function(){return h},toc:function(){return d},default:function(){return p}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),l=["components"],r={},s=void 0,h={unversionedId:"summary-of-Selections/04-04 strategies-and-methods-for-selections-existing-Worksheet",id:"summary-of-Selections/04-04 strategies-and-methods-for-selections-existing-Worksheet",title:"04-04 strategies-and-methods-for-selections-existing-Worksheet",description:"strategies and methods for selections, existing Worksheet",source:"@site/docs/04-summary-of-Selections/04-04 strategies-and-methods-for-selections-existing-Worksheet.md",sourceDirName:"04-summary-of-Selections",slug:"/summary-of-Selections/04-04 strategies-and-methods-for-selections-existing-Worksheet",permalink:"/docs/summary-of-Selections/04-04 strategies-and-methods-for-selections-existing-Worksheet",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/04-summary-of-Selections/04-04 strategies-and-methods-for-selections-existing-Worksheet.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"04-03 introduction-to-selections",permalink:"/docs/summary-of-Selections/04-03 introduction-to-selections"},next:{title:"overview of values and formulas",permalink:"/docs/overview-of-values-and-formulas/05 overview-of-values-and-formulas"}},d=[{value:"strategies and methods for selections, existing Worksheet",id:"strategies-and-methods-for-selections-existing-worksheet",children:[{value:"common aspects to working with a <code>Range</code>",id:"common-aspects-to-working-with-a-range",children:[],level:3},{value:"some simple techniques for finding a <code>Range</code>",id:"some-simple-techniques-for-finding-a-range",children:[{value:"Selection and ActiveCell",id:"selection-and-activecell",children:[{value:"Selection",id:"selection",children:[],level:5},{value:"ActiveCell",id:"activecell",children:[],level:5}],level:4}],level:3},{value:"Hard-code a cell reference",id:"hard-code-a-cell-reference",children:[{value:"<code>Range()</code>",id:"range",children:[],level:4},{value:"Cells()",id:"cells",children:[],level:4}],level:3},{value:"some simple techniques for finding a multi-cell <code>Range</code>",id:"some-simple-techniques-for-finding-a-multi-cell-range",children:[{value:"<code>Cells</code>",id:"cells-1",children:[],level:4},{value:"<code>UsedRange</code>",id:"usedrange",children:[],level:4}],level:3},{value:"finding a <code>Range</code> while iterating through a <code>Range</code>",id:"finding-a-range-while-iterating-through-a-range",children:[],level:3},{value:"finding a <code>Range</code> by paring down (or up) an existing Range",id:"finding-a-range-by-paring-down-or-up-an-existing-range",children:[{value:"move to a new spot, <code>Offset()</code> and <code>End()</code>",id:"move-to-a-new-spot-offset-and-end",children:[{value:"<code>Offset()</code>",id:"offset",children:[],level:5}],level:4},{value:"<code>End()</code>",id:"end",children:[{value:"RangeEnd.md",id:"rangeendmd",children:[],level:5},{value:"RangeEnd_Boundary.md",id:"rangeend_boundarymd",children:[],level:5}],level:4},{value:"Take a subset of an existing <code>Range</code> -- <code>Cells</code>, <code>Rows</code>, <code>Columns</code>, <code>Areas</code>",id:"take-a-subset-of-an-existing-range----cells-rows-columns-areas",children:[],level:4},{value:"Take a an existing <code>Range</code> and change its size -- <code>Resize()</code>",id:"take-a-an-existing-range-and-change-its-size----resize",children:[],level:4},{value:"Take a super set of an existing <code>Range</code> -- <code>EntireColumn</code>, <code>EntireRow</code>, <code>CurrentRegion</code>, <code>CurrentArray</code>",id:"take-a-super-set-of-an-existing-range----entirecolumn-entirerow-currentregion-currentarray",children:[],level:4},{value:"Allow Excel to filter the <code>Range</code> based on things it tracks (e.g. value, blank, hidden, etc.) -- <code>SpecialCells()</code>",id:"allow-excel-to-filter-the-range-based-on-things-it-tracks-eg-value-blank-hidden-etc----specialcells",children:[],level:4}],level:3},{value:"working with a <code>Range</code> via <code>Union</code> and <code>Intersect</code>",id:"working-with-a-range-via-union-and-intersect",children:[],level:3},{value:"the kitchen sink of remaining <code>Range</code> ideas",id:"the-kitchen-sink-of-remaining-range-ideas",children:[{value:"Objects that will return a Range",id:"objects-that-will-return-a-range",children:[],level:4},{value:"Using <code>Names().RefersToRange</code>",id:"using-namesreferstorange",children:[],level:4},{value:"Using <code>Application.InputBox(, Type:=8)</code>",id:"using-applicationinputbox-type8",children:[],level:4},{value:"Using <code>Application.Index</code>",id:"using-applicationindex",children:[],level:4},{value:"Using <code>Range.Find()</code>",id:"using-rangefind",children:[],level:4},{value:"Pulling a Range from a Formula with string processing",id:"pulling-a-range-from-a-formula-with-string-processing",children:[],level:4}],level:3},{value:"working with <code>Ranges</code> via advanced techniques",id:"working-with-ranges-via-advanced-techniques",children:[{value:"Offset-Intersect",id:"offset-intersect",children:[],level:4},{value:"AutoFilter and then SpecialCells",id:"autofilter-and-then-specialcells",children:[],level:4},{value:"The Duplicated Range on another Sheet",id:"the-duplicated-range-on-another-sheet",children:[],level:4}],level:3},{value:"Range via user input: InputBox",id:"range-via-user-input-inputbox",children:[{value:"GetInputOrSelection.md",id:"getinputorselectionmd",children:[],level:4}],level:3}],level:2}],u={toc:d};function p(e){var t=e.components,n=(0,i.Z)(e,l);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"strategies-and-methods-for-selections-existing-worksheet"},"strategies and methods for selections, existing Worksheet"),(0,o.kt)("p",null,"When working with data in an existing ",(0,o.kt)("inlineCode",{parentName:"p"},"Worksheet"),", the main goal is to find the section of the data that you actually want to process. This task can range from trivial to the bulk of the VBA code. A rough overview, starting with trivial is:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Use the selection -- ",(0,o.kt)("inlineCode",{parentName:"li"},"Selection")),(0,o.kt)("li",{parentName:"ul"},"Use the ActiveCell -- ",(0,o.kt)("inlineCode",{parentName:"li"},"ActiveCell")," (see later for why these are different)"),(0,o.kt)("li",{parentName:"ul"},"Hard-code the address of a single cell -- ",(0,o.kt)("inlineCode",{parentName:"li"},'Range("A1")')," or ",(0,o.kt)("inlineCode",{parentName:"li"},"Cells(1,1)")," (please don't use the latter)"),(0,o.kt)("li",{parentName:"ul"},"Name a cell and use that name directly -- ",(0,o.kt)("inlineCode",{parentName:"li"},'Range("CellName")')),(0,o.kt)("li",{parentName:"ul"},"Iterate through all cells -- ",(0,o.kt)("inlineCode",{parentName:"li"},"Cells"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"UsedRange")),(0,o.kt)("li",{parentName:"ul"},"While iterating through cells, use some logic to identify if a ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," is the one you want:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Check the ",(0,o.kt)("inlineCode",{parentName:"li"},"Value")," of the cell"),(0,o.kt)("li",{parentName:"ul"},"Check if the cell has some property (e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},"HasFormula"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"HasArray"),", etc.) ","*"," Check the ",(0,o.kt)("inlineCode",{parentName:"li"},"Style")," of the cell"))),(0,o.kt)("li",{parentName:"ul"},"Take an existing ",(0,o.kt)("inlineCode",{parentName:"li"},"Range"),", possibly all cells, and pare it down using:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Move from a known cell to a new spot -- ",(0,o.kt)("inlineCode",{parentName:"li"},"Offset()"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"End()")),(0,o.kt)("li",{parentName:"ul"},"Take a subset of an existing ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," -- ",(0,o.kt)("inlineCode",{parentName:"li"},"Cells"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Rows"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Columns"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Areas")),(0,o.kt)("li",{parentName:"ul"},"Take a an existing ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," and change its size -- ",(0,o.kt)("inlineCode",{parentName:"li"},"Resize()")),(0,o.kt)("li",{parentName:"ul"},"Take a super set of an existing ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," -- ",(0,o.kt)("inlineCode",{parentName:"li"},"EntireColumn"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"EntireRow"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"CurrentRegion"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"CurrentArray")," ","*"," Allow Excel to filter the ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," based on things it tracks (e.g. value, blank, hidden, etc.) -- ",(0,o.kt)("inlineCode",{parentName:"li"},"SpecialCells()")))),(0,o.kt)("li",{parentName:"ul"},"Identify several ",(0,o.kt)("inlineCode",{parentName:"li"},"Ranges")," and combine them -- ",(0,o.kt)("inlineCode",{parentName:"li"},"Union()")),(0,o.kt)("li",{parentName:"ul"},"Identify several ",(0,o.kt)("inlineCode",{parentName:"li"},"Ranges")," and use only the common cells -- ",(0,o.kt)("inlineCode",{parentName:"li"},"Intersect()")),(0,o.kt)("li",{parentName:"ul"},"Pull the ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," reference from some other object"),(0,o.kt)("li",{parentName:"ul"},"Name a cell and use that name indirectly -- ",(0,o.kt)("inlineCode",{parentName:"li"},'Names("CellName")')),(0,o.kt)("li",{parentName:"ul"},"Ask the user to select the ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," to use"),(0,o.kt)("li",{parentName:"ul"},"Use a function to get a reference -- ",(0,o.kt)("inlineCode",{parentName:"li"},"Application.Index")),(0,o.kt)("li",{parentName:"ul"},"Search for the cell based on its function or value -- ",(0,o.kt)("inlineCode",{parentName:"li"},"Find()")),(0,o.kt)("li",{parentName:"ul"},"Process a formula to determine the ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," it depends on")),(0,o.kt)("p",null,'In addition to those "simple" techniques above, there are more advanced techniques available. Those advanced techniques all rely on some combination of the above options, along with additional logic to manipulate the ',(0,o.kt)("inlineCode",{parentName:"p"},"Worksheet"),". A couple of combination techniques would include:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Use the Offset-Intersect technique to get a block of data without its header"),(0,o.kt)("li",{parentName:"ul"},"Use the ",(0,o.kt)("inlineCode",{parentName:"li"},"AutoFilter")," to filter a data set and then get the visible cells with ",(0,o.kt)("inlineCode",{parentName:"li"},"SpecialCells()")),(0,o.kt)("li",{parentName:"ul"},"Use one of the techniques above to get a ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," on one ",(0,o.kt)("inlineCode",{parentName:"li"},"Worksheet"),"; grab the corresponding ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," on a another ",(0,o.kt)("inlineCode",{parentName:"li"},"Worksheet")," to do some processing")),(0,o.kt)("h3",{id:"common-aspects-to-working-with-a-range"},"common aspects to working with a ",(0,o.kt)("inlineCode",{parentName:"h3"},"Range")),(0,o.kt)("p",null,"There are several common aspects of working with ",(0,o.kt)("inlineCode",{parentName:"p"},"Ranges"),". The most important thing is to remember the difference between using the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," as a reference or as a ",(0,o.kt)("inlineCode",{parentName:"p"},"Value"),". The problem comes because VBA will work really hard to allow your code to execute regardless of whether the Value/reference part is done correctly."),(0,o.kt)("p",null,"The difference is best explained with an example. In this example, you can see that when the reference is stored, you must use the ",(0,o.kt)("inlineCode",{parentName:"p"},"Set")," command. If you want the ",(0,o.kt)("inlineCode",{parentName:"p"},"Value")," of a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),", you can either use ",(0,o.kt)("inlineCode",{parentName:"p"},"Value")," or rely on VBA calling it implicitly otherwise. If you attempt to assign the ",(0,o.kt)("inlineCode",{parentName:"p"},"Value")," of a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," to a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," object, you will get an error. If you attempt to assign the ",(0,o.kt)("inlineCode",{parentName:"p"},"Value")," of a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," to a ",(0,o.kt)("inlineCode",{parentName:"p"},"Variant")," variable, it will work, but the variable will only hold the ",(0,o.kt)("inlineCode",{parentName:"p"},"Value"),". That is, you cannot make further calls from the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," object model. This should highlight the importance of declaring variables with the tightest scope on the variable type. If everything is a ",(0,o.kt)("inlineCode",{parentName:"p"},"Variant"),", VBA will let you get away with a lot; sometimes that flexibility will bite you."),(0,o.kt)("p",null,"TODO: add an example here"),(0,o.kt)("h3",{id:"some-simple-techniques-for-finding-a-range"},"some simple techniques for finding a ",(0,o.kt)("inlineCode",{parentName:"h3"},"Range")),(0,o.kt)("p",null,"The simple selection techniques consist of:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Use the ActiveCell -- ",(0,o.kt)("inlineCode",{parentName:"li"},"ActiveCell")," (see later for why these are different)"),(0,o.kt)("li",{parentName:"ul"},"Use the selection -- ",(0,o.kt)("inlineCode",{parentName:"li"},"Selection")),(0,o.kt)("li",{parentName:"ul"},"Hard-code the address of a single cell -- ",(0,o.kt)("inlineCode",{parentName:"li"},'Range("A1")')," or ",(0,o.kt)("inlineCode",{parentName:"li"},"Cells(1,1)")," (please don't use the latter)"),(0,o.kt)("li",{parentName:"ul"},"Name a cell and use that name directly -- ",(0,o.kt)("inlineCode",{parentName:"li"},'Range("CellName")'))),(0,o.kt)("p",null,"These are considered simple, but their simplicity means they are commonly used. These techniques can return a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," that represents either a single cell or multiple cells or a group of discontinuous cells. The one exception to this is the ",(0,o.kt)("inlineCode",{parentName:"p"},"ActiveCell"),"; it is always a single cell."),(0,o.kt)("h4",{id:"selection-and-activecell"},"Selection and ActiveCell"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Selection")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ActiveCell")," commands both work based on what is currently going on with the active spreadsheet. In particular, they work on the current selection of the ",(0,o.kt)("inlineCode",{parentName:"p"},"ActiveSheet")," in the ",(0,o.kt)("inlineCode",{parentName:"p"},"ActiveWorkbook"),". For a normal workflow, the active sheet and workbook are the ones with focus (or that last had focus). When working through an involved workflow, you can control the ",(0,o.kt)("inlineCode",{parentName:"p"},"ActiveSheet")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ActiveWorkbook"),". In general, you should not use these commands in an involved workflow without a very good reason."),(0,o.kt)("h5",{id:"selection"},"Selection"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Selection")," is a catch all object that refers to anything that is selected. If the current selection is a group of cells, then you get a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),". If instead the selection is a Chart, Shape, button, or some other non-",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),", then you will get an error if you assume that it has type ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),". When working with the ",(0,o.kt)("inlineCode",{parentName:"p"},"Selection"),", it is always good to assign a new ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," variable equal to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Selection"),". This ensures that you get Intellisense for commands and also ensures that VBA will throw an error if the ",(0,o.kt)("inlineCode",{parentName:"p"},"Selection")," is something other than a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),"."),(0,o.kt)("h5",{id:"activecell"},"ActiveCell"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ActiveCell")," always refers to a single cell. If the current ",(0,o.kt)("inlineCode",{parentName:"p"},"Selection")," is a single cell, then these will refer to the same ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),". If the current ",(0,o.kt)("inlineCode",{parentName:"p"},"Selection")," is a multi-cell ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),", then the ",(0,o.kt)("inlineCode",{parentName:"p"},"ActiveCell")," is the cell that currently has focus. When normally editing cells, you have some control over which cell in a multi-cell ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," is active. This can be changed by hitting ",(0,o.kt)("inlineCode",{parentName:"p"},"CTRL+."),", ",(0,o.kt)("inlineCode",{parentName:"p"},"SHIFT+Enter"),". This functionality in Excel is what allows an array formula to be applied to a larger range. You select a multi cell ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," and then enter the formula with ",(0,o.kt)("inlineCode",{parentName:"p"},"CTRL+SHIFT+Enter"),". This in turn will apply the formula to all cells."),(0,o.kt)("p",null,"TODO: what happens when the ",(0,o.kt)("inlineCode",{parentName:"p"},"Selection")," is not a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),"? Does this still work?"),(0,o.kt)("h3",{id:"hard-code-a-cell-reference"},"Hard-code a cell reference"),(0,o.kt)("p",null,"The second most common way of getting access to a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," is to simply give Excel the address of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," to work with. This is a convenient way of working with ",(0,o.kt)("inlineCode",{parentName:"p"},"Ranges")," because it can be easily checked against normal Excel formulas and addresses. The common ways of doing this are using the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Cells")," functions with the appropriate parameters."),(0,o.kt)("p",null,'When working with these functions, it is possible to use them "bare" or unqualified. That is, you can just type ',(0,o.kt)("inlineCode",{parentName:"p"},"Range()")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"Cells()")," and it will work. Specifically, it will work on the ",(0,o.kt)("inlineCode",{parentName:"p"},"ActiveSheet")," of the ",(0,o.kt)("inlineCode",{parentName:"p"},"ActiveWorkbook"),". This can lead to some difficulties when working with multiple ",(0,o.kt)("inlineCode",{parentName:"p"},"Worksheets")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"Workbooks"),". If you are working across contexts (",(0,o.kt)("inlineCode",{parentName:"p"},"Worksheets")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"Workbooks"),"), you should generally qualify your reference to the widest context required. This is done by calling the appropriate function on the appropriate object/context. If you have multiple ",(0,o.kt)("inlineCode",{parentName:"p"},"Worksheets"),", you would call ",(0,o.kt)("inlineCode",{parentName:"p"},"Worksheet.Range()")," or specifically ",(0,o.kt)("inlineCode",{parentName:"p"},'Sheets("SheetName").Range()')," in order to access a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," on that specific ",(0,o.kt)("inlineCode",{parentName:"p"},"Worksheet"),". If you are working with multiple ",(0,o.kt)("inlineCode",{parentName:"p"},"Workbooks"),", you still only need a reference to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Worksheet"),", but you will have to go through the correct ",(0,o.kt)("inlineCode",{parentName:"p"},"Workbook")," first. This looks like: ",(0,o.kt)("inlineCode",{parentName:"p"},"Workbooks(1).Worksheets(1).Range"),". If you've previously stored a reference to a ",(0,o.kt)("inlineCode",{parentName:"p"},"Worksheet"),", you do not have to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"Workbook")," also; it is very common when working across ",(0,o.kt)("inlineCode",{parentName:"p"},"Workbooks")," to store a ",(0,o.kt)("inlineCode",{parentName:"p"},"Worksheet")," reference as you go (for this reason)."),(0,o.kt)("p",null,"This caveat about qualifying a reference brings up an important point: a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," can only refer to cells that are on the same ",(0,o.kt)("inlineCode",{parentName:"p"},"Worksheet"),". You are not allowed to create a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," across multiple ",(0,o.kt)("inlineCode",{parentName:"p"},"Worksheets"),". (TODO: what happens if you try this?). If you want to work with ",(0,o.kt)("inlineCode",{parentName:"p"},"Ranges")," on multiple ",(0,o.kt)("inlineCode",{parentName:"p"},"Worksheets"),", you will need to iterate through the ",(0,o.kt)("inlineCode",{parentName:"p"},"Worksheets"),"."),(0,o.kt)("h4",{id:"range"},(0,o.kt)("inlineCode",{parentName:"h4"},"Range()")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Range()")," function is the powerhouse of cell referencing. It works hard to take whatever you give it and return a valid cell reference. It can process the same commands as the address bar in Excel. That is, it will parse:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"a cell reference (",(0,o.kt)("inlineCode",{parentName:"li"},"A1"),")"),(0,o.kt)("li",{parentName:"ul"},"a multi-cell reference (",(0,o.kt)("inlineCode",{parentName:"li"},"A1:B5"),")"),(0,o.kt)("li",{parentName:"ul"},"a discontinuous reference using a union (",(0,o.kt)("inlineCode",{parentName:"li"},"(A1, B1, C1)"),")"),(0,o.kt)("li",{parentName:"ul"},"a discontinuous reference using an intersect (",(0,o.kt)("inlineCode",{parentName:"li"},"(A:A 1:1)"),") -- Note this will return the cell ",(0,o.kt)("inlineCode",{parentName:"li"},"A1")," which is at the intersection of the two given references. Also note that this way of referencing cells is incredibly rare (I've never used it in a real application)."),(0,o.kt)("li",{parentName:"ul"},"a named range (",(0,o.kt)("inlineCode",{parentName:"li"},"some_named_range"),")"),(0,o.kt)("li",{parentName:"ul"},"any application of the multi cell references with named ranges")),(0,o.kt)("p",null,"TODO: can the Range handle a function in it?"),(0,o.kt)("p",null,"Alongside that power of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range()"),", you can also use it to refer to a group of cells using the corners of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),". This can be used to either return a group of cells in the same row/column, or it can be used to grab a block of data. You are free to give the cells in whatever order you'd like (not required to be top left and bottom right)."),(0,o.kt)("p",null,"This multi-cell version of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range()")," function is quite powerful when you know or can determine the corners of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," you want. In particular, this works well with the ",(0,o.kt)("inlineCode",{parentName:"p"},"End()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Offset()")," functions to build ",(0,o.kt)("inlineCode",{parentName:"p"},"Ranges")," from a single starting point."),(0,o.kt)("p",null,"If you thought the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range()")," couldn't get any better, it has one last trick up its sleeve. It can also take parameters that are of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," type when building a multi cell ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),". This is quite powerful because it means you can use any of the techniques to find a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," and then get a block of data by feeding them to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range()")," function. This saves the hassle of calling ",(0,o.kt)("inlineCode",{parentName:"p"},"Range(someRange.Address, someOtherRange.Address)")," just to build the block."),(0,o.kt)("p",null,"There is one approach to using the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," function that is effective but can be a bad crutch. It involves building a ",(0,o.kt)("inlineCode",{parentName:"p"},"String")," to feed to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range()")," function. This usually looks like ",(0,o.kt)("inlineCode",{parentName:"p"},'Range("A" & Cells(1,1).Column)')," or something similar. There are legitimate cases where this is a quick and easy way out of a problem. It generally involves knowing that you want a cell from a specific row or column while also knowing the other piece (column or row) from an existing cell. You can quickly combine the two to get your reference. There is nothing wrong with building a ",(0,o.kt)("inlineCode",{parentName:"p"},"String")," here, but it might be a sign that there was a better way to get the reference from the start. It can be helpful when working with far to the right columns that are not easily thought of as a number; what column is ",(0,o.kt)("inlineCode",{parentName:"p"},"AB6")," again?"),(0,o.kt)("p",null,"When considering whether and how to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range()")," function, the main things to consider are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"How stable does this code need to be?"),(0,o.kt)("li",{parentName:"ul"},"How likely am I to change the address of the cell I want?"),(0,o.kt)("li",{parentName:"ul"},"Will a given cell always be in the same place?"),(0,o.kt)("li",{parentName:"ul"},"Will a given name always exist?")),(0,o.kt)("p",null,"This questions are pointing to some of the downfalls of ",(0,o.kt)("inlineCode",{parentName:"p"},"Range()"),". The biggest downfall is that if you are going to use ",(0,o.kt)("inlineCode",{parentName:"p"},'Range("A1")')," to refer to cell ",(0,o.kt)("inlineCode",{parentName:"p"},"A1"),", your VBA code will not work if that cell moves for some reason. Furthermore, it can be a real pain to identify when code is failing because of a bad cell reference. I've had it happen countless times now where I hard-code a cell reference, use that in VBA, and then break things completely by adding a row or column somewhere. This is akin to using ",(0,o.kt)("inlineCode",{parentName:"p"},"VLOOKUP")," and inserting a column in the middle of the lookup range; your code will not know or adjust to the new reference. Even worse, depending on what your code does, it's entirely likely that it will run just fine with the mistake. This is the most pernicious type of error to debug in a complicated program."),(0,o.kt)("p",null,'The upside of this dilemma is that you can quickly remedy the situation by using a named range to refer to the cell. If you name the cell on the Excel side of things, you get the benefit of Excel moving the reference around if the underlying cell moves. This is an incredibly powerful technique. More emphatically, this is the fastest way to "level up" your VBA if you are just getting started. Robust VBA generally relies on named ranges on the underlying spreadsheet. It takes very regular spreadsheets to get away hard-coded references. As a tip, the second time you manually increment 10+ ',(0,o.kt)("inlineCode",{parentName:"p"},'Range("A1")')," calls because of a new row is the last time you want to do that."),(0,o.kt)("p",null,"A common technique for building macros quickly is to start with hard coded references and convert them to named ranges once the spreadsheet takes form. There is nothing wrong with naming ranges early and not needing them, but it can take more time than it's worth to name the ranges instead of hard-coding a reference. Again, this can burn you quickly if you have to manually change several of those references."),(0,o.kt)("h4",{id:"cells"},"Cells()"),(0,o.kt)("p",null,"A convenient but less powerful version of ",(0,o.kt)("inlineCode",{parentName:"p"},"Range()")," is the ",(0,o.kt)("inlineCode",{parentName:"p"},"Cells()")," function. ",(0,o.kt)("inlineCode",{parentName:"p"},"Cells()")," is much simpler since it only requires a row or column number for the reference. This can be useful to quickly grab a reference if you know the row or column number (or both). It's far more likely that you know the Excel reference you want -- ",(0,o.kt)("inlineCode",{parentName:"p"},"A1")," -- than that you know the exact row and column number. It's the column number that is always a pain to determine. Some folks try to get around this by using the ",(0,o.kt)("inlineCode",{parentName:"p"},"Asc() - 65")," approach to get the number for the letter and send that into ",(0,o.kt)("inlineCode",{parentName:"p"},"Cell1()"),". Once you know about the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range()")," function, you'll never touch that madness again."),(0,o.kt)("p",null,"So, if the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range()")," function is typically more useful and powerful than ",(0,o.kt)("inlineCode",{parentName:"p"},"Cells()"),", why would you ever use ",(0,o.kt)("inlineCode",{parentName:"p"},"Cells()"),"? Well, ",(0,o.kt)("inlineCode",{parentName:"p"},"Cells()")," is the entry point for iterating through the cells in a multi-cell ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),". This use of ",(0,o.kt)("inlineCode",{parentName:"p"},"Cells")," will be covered later on, but it's mentioned here because it's incredibly powerful in that context. Specifically, if you have a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," already, you can use ",(0,o.kt)("inlineCode",{parentName:"p"},"Range.Cells()")," to grab a cell within that ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," at the specific spot. In this way, ",(0,o.kt)("inlineCode",{parentName:"p"},"Cells()")," is actually useful because the indices are smaller and typically correspond to the actual application at hand. Again, this is covered later."),(0,o.kt)("p",null,"TODO: add a link to the section where iteration is covered"),(0,o.kt)("h3",{id:"some-simple-techniques-for-finding-a-multi-cell-range"},"some simple techniques for finding a multi-cell ",(0,o.kt)("inlineCode",{parentName:"h3"},"Range")),(0,o.kt)("p",null,"The simple selection technique for working with multiple cells consist of:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Iterate through all cells -- ",(0,o.kt)("inlineCode",{parentName:"li"},"Cells"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"UsedRange")),(0,o.kt)("li",{parentName:"ul"},"Building a range from the corners -- ",(0,o.kt)("inlineCode",{parentName:"li"},"Range()"))),(0,o.kt)("p",null,"The previous section identified the simplest techniques for obtaining a reference to a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),". Those techniques touched on single and multi-cell ",(0,o.kt)("inlineCode",{parentName:"p"},"Ranges"),". There are a couple of additional techniques for obtaining a multi-cell ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," that are used commonly."),(0,o.kt)("p",null,"The typical goal of these multi-cell calls is to take the reference and iterate through the cells. To iterate through the cells, there are two techniques, ",(0,o.kt)("inlineCode",{parentName:"p"},"For Each")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"For")," loops. The former is vastly preferred to the latter in nearly all cases. I'll say that again, if you're iterating through cells, you should strongly prefer to use a ",(0,o.kt)("inlineCode",{parentName:"p"},"For Each")," loop instead of a simple ",(0,o.kt)("inlineCode",{parentName:"p"},"For")," loop. Those two examples look like:"),(0,o.kt)("p",null,"TODO: add code samples for ",(0,o.kt)("inlineCode",{parentName:"p"},"For")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"For Each")," loops"),(0,o.kt)("h4",{id:"cells-1"},(0,o.kt)("inlineCode",{parentName:"h4"},"Cells")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Cells")," call exists on several different objects. The easiest way to access it is via the bare, unqualified, reference -- just type ",(0,o.kt)("inlineCode",{parentName:"p"},"Cells"),". It applies to the ",(0,o.kt)("inlineCode",{parentName:"p"},"ActiveSheet")," of the ",(0,o.kt)("inlineCode",{parentName:"p"},"ActiveWorkbook"),". Typically, you should avoid iterating all ",(0,o.kt)("inlineCode",{parentName:"p"},"Cells")," unless you know you will break out of the loop at some point. There are a lot of cells in a ",(0,o.kt)("inlineCode",{parentName:"p"},"Worksheet"),", and your code will grind to a halt working through rows 10100 to 132000 doing a bunch of nothing on empty cells."),(0,o.kt)("h4",{id:"usedrange"},(0,o.kt)("inlineCode",{parentName:"h4"},"UsedRange")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"UsedRange")," is available on a ",(0,o.kt)("inlineCode",{parentName:"p"},"Worksheet"),". It also exists as a bare unqualified reference applying to the ",(0,o.kt)("inlineCode",{parentName:"p"},"ActiveSheet")," of the ",(0,o.kt)("inlineCode",{parentName:"p"},"ActiveWorkbook"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"UsedRange")," is a slightly complicated function but its goal is to provide you a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," that provides a bounding box on all of the used cells in the current ",(0,o.kt)("inlineCode",{parentName:"p"},"Worksheet"),". The complication of ",(0,o.kt)("inlineCode",{parentName:"p"},"UsedRange")," comes when determining what is a \"used\" cell. Excel will consider a cell used if it has a non default property for its value or formatting. The formatting part of the definition can throw you for a loop because it's possible to change the formatting in a non-obvious way (e.g. it's impossible to spot the font size of an empty cell). There are several well-regarded folks who will advocate against the ",(0,o.kt)("inlineCode",{parentName:"p"},"UsedRange")," in all cases. Their argument is that the ",(0,o.kt)("inlineCode",{parentName:"p"},"UsedRange")," is too undependable because it can be thrown off too easily. In my experience, the ",(0,o.kt)("inlineCode",{parentName:"p"},"UsedRange")," is a powerful way to leverage Excel tracking the internal state of the spreadsheet. You can also avoid most of the issues with the ",(0,o.kt)("inlineCode",{parentName:"p"},"UsedRange")," not matching expectations by taking care of the state of the spreadsheet. If a ",(0,o.kt)("inlineCode",{parentName:"p"},"Worksheet")," was under your control, there's no reason to avoid the ",(0,o.kt)("inlineCode",{parentName:"p"},"UsedRange"),". As a first tip, the ",(0,o.kt)("inlineCode",{parentName:"p"},"UsedRange"),' matches the scrollbars around the spreadsheet. If the scrollbars stop scrolling when you reach the "end of the spreadsheet", then the ',(0,o.kt)("inlineCode",{parentName:"p"},"UsedRange")," is good to go. You can also do a quick test with ",(0,o.kt)("inlineCode",{parentName:"p"},"UsedRange.Address")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"UsedRange.CountLarge")," to see what it refers to. Again, I think the arguments against the ",(0,o.kt)("inlineCode",{parentName:"p"},"UsedRange")," are overly cautious, and it's a great command in a well managed spreadsheet."),(0,o.kt)("p",null,"TODO: is ",(0,o.kt)("inlineCode",{parentName:"p"},"UsedRange")," available bare?"),(0,o.kt)("h3",{id:"finding-a-range-while-iterating-through-a-range"},"finding a ",(0,o.kt)("inlineCode",{parentName:"h3"},"Range")," while iterating through a ",(0,o.kt)("inlineCode",{parentName:"h3"},"Range")),(0,o.kt)("p",null,"One technique for working with Ranges is to start with one Range, iterate though it, can build a new Range based on some criteria. Alternatively, you may just act immediately on the Range as you are iterating through it. This approach is dead simple and is used in abundance throughout good workflows. As long as there is some meaningful logic which can be applied to identify whether or not a subset of a Range is interesting, you can use this technique. Some common logical steps that are checked:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Check the ",(0,o.kt)("inlineCode",{parentName:"li"},"Value")," of the cell"),(0,o.kt)("li",{parentName:"ul"},"Check if the cell has some property (e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},"HasFormula"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"HasArray"),", etc.)"),(0,o.kt)("li",{parentName:"ul"},"Check the ",(0,o.kt)("inlineCode",{parentName:"li"},"Style")," of the cell")),(0,o.kt)("p",null,"The idea is simple: check some property while iterating and act on it. This is obvious once you have been programming for a bit, but sometimes you just need to be told that this is an acceptable way of doing things. You do not always need to use ",(0,o.kt)("inlineCode",{parentName:"p"},"Find")," to search for a cell that contains some value. You can always just iterate all the cells and see if a cell matches that value (or contains it with ",(0,o.kt)("inlineCode",{parentName:"p"},"InStr"),")."),(0,o.kt)("p",null,"TODO: find some code related to this?"),(0,o.kt)("h3",{id:"finding-a-range-by-paring-down-or-up-an-existing-range"},"finding a ",(0,o.kt)("inlineCode",{parentName:"h3"},"Range")," by paring down (or up) an existing Range"),(0,o.kt)("p",null,"One of the key ways to access a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," is to use an existing ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," and modify it slightly. This might prompt the question: how do I get the first ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," in order to use that? Well, check the previous section for the most common techniques. You can always start with ",(0,o.kt)("inlineCode",{parentName:"p"},"ActiveCell")," if you just want to see these in action."),(0,o.kt)("p",null,"Using a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," to get the next ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," really is the bread and butter of serious VBA development. It is a very common pattern to identify a single ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," in a ",(0,o.kt)("inlineCode",{parentName:"p"},"Worksheet"),' that is critical to the rest of the spreadsheet and use that as an "anchor" to access the rest of the cells. This is particularly common when the data is structured in some way that can be utilized.'),(0,o.kt)("p",null,"When using these techniques, there are a couple of common strategies. They work by either paring down the current ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),", moving the current ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),", or using the current ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," as the start of some expansion. Of course, since a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," can be used to access a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),", you will quickly find yourself chaining these functions together. That is the true power of these techniques. Very often you will use 2 or 3 to take a single cell, move to a new spot, resize to cover all of the data and then move over a column to do something."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Take an existing ",(0,o.kt)("inlineCode",{parentName:"li"},"Range"),", possibly all cells, and pare it down using:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Move from a known cell to a new spot -- ",(0,o.kt)("inlineCode",{parentName:"li"},"Offset()"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"End()")),(0,o.kt)("li",{parentName:"ul"},"Take a subset of an existing ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," -- ",(0,o.kt)("inlineCode",{parentName:"li"},"Cells"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Rows"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Columns"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Areas")),(0,o.kt)("li",{parentName:"ul"},"Take a an existing ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," and change its size -- ",(0,o.kt)("inlineCode",{parentName:"li"},"Resize()")),(0,o.kt)("li",{parentName:"ul"},"Take a super set of an existing ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," -- ",(0,o.kt)("inlineCode",{parentName:"li"},"EntireColumn"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"EntireRow"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"CurrentRegion"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"CurrentArray")," ","*"," Allow Excel to filter the ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," based on things it tracks (e.g. value, blank, hidden, etc.) -- ",(0,o.kt)("inlineCode",{parentName:"li"},"SpecialCells()"))))),(0,o.kt)("h4",{id:"move-to-a-new-spot-offset-and-end"},"move to a new spot, ",(0,o.kt)("inlineCode",{parentName:"h4"},"Offset()")," and ",(0,o.kt)("inlineCode",{parentName:"h4"},"End()")),(0,o.kt)("p",null,'There are two simple ways to "move" from a given ',(0,o.kt)("inlineCode",{parentName:"p"},"Range")," to a new ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),", namely using ",(0,o.kt)("inlineCode",{parentName:"p"},"Offset()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"End()"),". Both of these take an existing ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," and return a new one. ",(0,o.kt)("inlineCode",{parentName:"p"},"Offset()")," will not modify the size of the current ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),"; it will just move it. ",(0,o.kt)("inlineCode",{parentName:"p"},"End()")," will always return a single cell even if the starting ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," was multi-cell."),(0,o.kt)("h5",{id:"offset"},(0,o.kt)("inlineCode",{parentName:"h5"},"Offset()")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Offset(rows, columns)")," works by moving the given ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," over by the parameters given to it. The nice thing about ",(0,o.kt)("inlineCode",{parentName:"p"},"Offset()")," is that the parameters can be negative to move backwards. There are a couple of simple use cases for ",(0,o.kt)("inlineCode",{parentName:"p"},"Offset()"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Work your way down or across a group of cells, by ",(0,o.kt)("inlineCode",{parentName:"li"},"Offsetting()")," and setting a reference to the new cell",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"This is often paired with a ",(0,o.kt)("inlineCode",{parentName:"li"},"While")," loop to work down a ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")),(0,o.kt)("li",{parentName:"ul"},"This is also helpful when you are not exactly sure what ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," you want (maybe it's dependent on cell values) so you can't simply assign the correct multi-cell ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," at the start."))),(0,o.kt)("li",{parentName:"ul"},"Use an existing ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," to get the starting point for a ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," and move over to a neighbor cell or a blank area to do something",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"This is common when using one cell's value to determine the value of the next one (e.g. splitting on a delimiter)"),(0,o.kt)("li",{parentName:"ul"},"This is also common when adding formulas to a spreadsheet. Find the current data, ",(0,o.kt)("inlineCode",{parentName:"li"},"Offset()")," over a column and apply the formula to all cells. ","*",' Also helpful when you "just know" that a desired ',(0,o.kt)("inlineCode",{parentName:"li"},"Range")," is some distance away from the ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," you've got. This is not the most elegant code at times (since it breaks easily), but it works reliably when you control the spreadsheet.")))),(0,o.kt)("p",null,"TODO: add a while loop example"),(0,o.kt)("p",null,"TODO: add a formula example"),(0,o.kt)("h4",{id:"end"},(0,o.kt)("inlineCode",{parentName:"h4"},"End()")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"End(xlDirection)")," is a powerful function for its specific use case. It replicates the functionality of the ",(0,o.kt)("inlineCode",{parentName:"p"},"CTRL+Arrow")," keyboard shortcuts. It will move from the current ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," as far as possible in a given direction so long as the cells are contiguous. Contiguous in this sense refers to the fact that the cells must not have a blank cell in between them. A blank cell is any cell that does not have a value ",(0,o.kt)("em",{parentName:"p"},"or")," a formula. The formula part is important because you can use a formula to return ",(0,o.kt)("inlineCode",{parentName:"p"},'""')," while still counting as a contiguous ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"End()")," takes a parameter which is the direction to travel in. You can go all 4 directions, up/down and left/right."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"End()")," will always return a single cell as the reference. This often means that ",(0,o.kt)("inlineCode",{parentName:"p"},"End()")," is used alongside a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range(Range, Range)")," to get a multi-cell ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," that spans from the start cell to the end cell. This is so common of a pattern, that I typically add a UDF that handles this logic directly."),(0,o.kt)("p",null,"TODO: add the function that is used ",(0,o.kt)("inlineCode",{parentName:"p"},"RangeEnd")),(0,o.kt)("p",null,"There are a few common patterns when working with ",(0,o.kt)("inlineCode",{parentName:"p"},"End()"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Use a ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," that you know is at the top of a block of data and use ",(0,o.kt)("inlineCode",{parentName:"li"},"End(xlDown)")," to get to the bottom of the column.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"This can be combined with ",(0,o.kt)("inlineCode",{parentName:"li"},"Range(Range, Range)")," to get the full multi-cell ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," to work through"),(0,o.kt)("li",{parentName:"ul"},"This technique is very powerful when redefining the ",(0,o.kt)("inlineCode",{parentName:"li"},"Ranges")," of a chart to include all of the cells (this can also be used for formulas too)."))),(0,o.kt)("li",{parentName:"ul"},"If you know your data has blanks, you can use ",(0,o.kt)("inlineCode",{parentName:"li"},"End()")," to jump to the next non-blank cell. ","*"," This is helpful if you are trying to fill in blank cells (TODO: add the Waterfall fill here)")),(0,o.kt)("h5",{id:"rangeendmd"},"RangeEnd.md"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-vb"},"Public Function RangeEnd(ByVal rangeBegin As Range, ByVal firstDirection As XlDirection, Optional ByVal secondDirection As XlDirection = -1) As Range\n\n    If secondDirection = -1 Then\n        Set RangeEnd = Range(rangeBegin, rangeBegin.End(firstDirection))\n    Else\n        Set RangeEnd = Range(rangeBegin, rangeBegin.End(firstDirection).End(secondDirection))\n    End If\nEnd Function\n")),(0,o.kt)("h5",{id:"rangeend_boundarymd"},"RangeEnd_Boundary.md"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-vb"},"Public Function RangeEnd_Boundary(ByVal rangeBegin As Range, ByVal firstDirection As XlDirection, Optional ByVal secondDirection As XlDirection = -1) As Range\n\n    If secondDirection = -1 Then\n        Set RangeEnd_Boundary = Intersect(Range(rangeBegin, rangeBegin.End(firstDirection)), rangeBegin.CurrentRegion)\n    Else\n        Set RangeEnd_Boundary = Intersect(Range(rangeBegin, rangeBegin.End(firstDirection).End(secondDirection)), rangeBegin.CurrentRegion)\n    End If\nEnd Function\n")),(0,o.kt)("h4",{id:"take-a-subset-of-an-existing-range----cells-rows-columns-areas"},"Take a subset of an existing ",(0,o.kt)("inlineCode",{parentName:"h4"},"Range")," -- ",(0,o.kt)("inlineCode",{parentName:"h4"},"Cells"),", ",(0,o.kt)("inlineCode",{parentName:"h4"},"Rows"),", ",(0,o.kt)("inlineCode",{parentName:"h4"},"Columns"),", ",(0,o.kt)("inlineCode",{parentName:"h4"},"Areas")),(0,o.kt)("p",null,"The subset functions work by providing you with a Range that is created from another Range based on some condition. They can be quite useful for building a workflow that makes it very explicit how you are trying to iterate through a Range or what you are searching for. The idea is that you know your starting Range contains some pieces that you would like to iterate through. The grouping goes from smallest unit to largest:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},'Cells will return a "flat" list of all cells with in the Range. No grouping left.'),(0,o.kt)("li",{parentName:"ul"},'Rows and Columns will each return a new utterable object built of the previous Range sliced into its Rows or Columns. If call them in order, it will look the same as iterating through Cells except that the order may be difference (TODO: how does this work?). Be sure that if you want to use these, avoid the properties with the "s". If you call Row ro Column, you will just get a number instead of a group of Ranges'),(0,o.kt)("li",{parentName:"ul"},"Areas will return a group of cells that may contain groups of Rows or Columns or just individual Cells. Areas are commonly built by users using ",(0,o.kt)("inlineCode",{parentName:"li"},"CTRL")," to select multiple things or by VBA which uses ",(0,o.kt)("inlineCode",{parentName:"li"},"Union")," to build Ranges.")),(0,o.kt)("p",null,"TODO: add some specific code related to Columns and Rows... that code is quite useful as a replacement to Cells(i,j)"),(0,o.kt)("p",null,"TODO: give an example of using Areas"),(0,o.kt)("h4",{id:"take-a-an-existing-range-and-change-its-size----resize"},"Take a an existing ",(0,o.kt)("inlineCode",{parentName:"h4"},"Range")," and change its size -- ",(0,o.kt)("inlineCode",{parentName:"h4"},"Resize()")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Resize()")," is a straightforward function that does exactly what you expect. It takes a current ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," and resizes it to contain the number of rows and columns specified. The most common uses of a ",(0,o.kt)("inlineCode",{parentName:"p"},"Resize()")," are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"You know where you want some output to start and its size, so you ",(0,o.kt)("inlineCode",{parentName:"li"},"Resize()")," to get a ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," that will hold all of the data."),(0,o.kt)("li",{parentName:"ul"},"You know that some data starts at a given cell and its size, so you ",(0,o.kt)("inlineCode",{parentName:"li"},"Resize()")," and call ",(0,o.kt)("inlineCode",{parentName:"li"},"Value")," to get an array of that data."),(0,o.kt)("li",{parentName:"ul"},"You would like to extend or change a formula based on some condition, so you ",(0,o.kt)("inlineCode",{parentName:"li"},"Resize")," and apply the formula down the line")),(0,o.kt)("p",null,"In general, these uses follow a pattern: you know what size you want the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," to be (or can compute the size) and ",(0,o.kt)("inlineCode",{parentName:"p"},"Resize")," gives you the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," back. This is one of the least controversial of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," methods. Enough said."),(0,o.kt)("p",null,"TODO: how does this handle negative numbers"),(0,o.kt)("p",null,"TODO: how does this handle a multi-cell range, does it always pick top left?"),(0,o.kt)("h4",{id:"take-a-super-set-of-an-existing-range----entirecolumn-entirerow-currentregion-currentarray"},"Take a super set of an existing ",(0,o.kt)("inlineCode",{parentName:"h4"},"Range")," -- ",(0,o.kt)("inlineCode",{parentName:"h4"},"EntireColumn"),", ",(0,o.kt)("inlineCode",{parentName:"h4"},"EntireRow"),", ",(0,o.kt)("inlineCode",{parentName:"h4"},"CurrentRegion"),", ",(0,o.kt)("inlineCode",{parentName:"h4"},"CurrentArray")),(0,o.kt)("p",null,'These "super set" functions work by taking a starting point and expanding it to include more cells. These will grow the ',(0,o.kt)("inlineCode",{parentName:"p"},"Range"),". Of the four listed above, ",(0,o.kt)("inlineCode",{parentName:"p"},"CurrentArray")," is the only one that requires some special case. That is, the current cell must be a part of an array formula. The others will always work. These functions are best thought of with their keyboard shortcut equivalents:"),(0,o.kt)("p",null,"TODO: extract this table along with others and make a single big table somewhere"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"shortcut"),(0,o.kt)("th",{parentName:"tr",align:null},"Range function"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"SHIFT + SPACE"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"EntireRow()"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"CTRL + SPACE"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"EntireColumn()"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"CTRL + A"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"CurrentRegion()"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"CTRL + /"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"CurrentArray()"))))),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"CurrentRegion")," is really only as useful as the data on the spreadsheet. If you have a large block of data, it works well to get the entire region. If you have blanks in your data, it's a bit of an unknown to know in advance what ",(0,o.kt)("inlineCode",{parentName:"p"},"CurrentRegion")," will give you. Typically, if you know you have a block of data, it can be a quick shortcut to using ",(0,o.kt)("inlineCode",{parentName:"p"},"End()")," twice. In general, I avoid it."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"EntireRow")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"EntireColumn")," are somewhat special because they can be used to make modifications to the rows and columns in Excel. In particular, they are needed if you want to insert a row/column, delete a row/column, change the row/column formatting, or change the height/width of the row/column. You can also use ",(0,o.kt)("inlineCode",{parentName:"p"},'Range("A:A")')," or similar to get a reference to the entire column, but it is much simpler to have a reference to a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," of a single cell and work out from there. Even better, if you have a multi-cell ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),", the ",(0,o.kt)("inlineCode",{parentName:"p"},"Entire")," functions will return the combination of all the rows or columns contained in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),"."),(0,o.kt)("p",null,"In addition to modifying the rows/columns of a ",(0,o.kt)("inlineCode",{parentName:"p"},"Worksheet"),", the ",(0,o.kt)("inlineCode",{parentName:"p"},"Entire")," functions also work very nicely with ",(0,o.kt)("inlineCode",{parentName:"p"},"Intersect()")," to get group of cells that are in a specific row/column. The ",(0,o.kt)("inlineCode",{parentName:"p"},"Entire")," functions are generally much nicer than trying to build the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," from address or any other technique."),(0,o.kt)("p",null,"TODO: is this true? Does it work for a multi-cell in this way?"),(0,o.kt)("h4",{id:"allow-excel-to-filter-the-range-based-on-things-it-tracks-eg-value-blank-hidden-etc----specialcells"},"Allow Excel to filter the ",(0,o.kt)("inlineCode",{parentName:"h4"},"Range")," based on things it tracks (e.g. value, blank, hidden, etc.) -- ",(0,o.kt)("inlineCode",{parentName:"h4"},"SpecialCells()")),(0,o.kt)("p",null,"The final function in this round up is also the most powerful at times: ",(0,o.kt)("inlineCode",{parentName:"p"},"SpecialCells()"),'. This function works by taking a parameter how which "special" cells to return. Special is a bad name here, because the most common uses of ',(0,o.kt)("inlineCode",{parentName:"p"},"SpecialCells")," are to grab cells that are formula, values, blanks, or visible. These are some of the more mundane properties of a cell. Name aside, ",(0,o.kt)("inlineCode",{parentName:"p"},"SpecialCells()")," can really take your VBA to the next level with very little effort."),(0,o.kt)("p",null,"An example: if you have ever iterated through ",(0,o.kt)("inlineCode",{parentName:"p"},"UsedRange")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"Cells")," with something that checks for ",(0,o.kt)("inlineCode",{parentName:"p"},'rng.Value = ""')," then you could have saved a loop by using ",(0,o.kt)("inlineCode",{parentName:"p"},"SpecialCells(xlCellTypeBlanks)")," instead. This will return a new ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," that only contains the blank cells. There are similar special types for other things that commonly come up."),(0,o.kt)("p",null,"One particular application of ",(0,o.kt)("inlineCode",{parentName:"p"},"SpecialCells")," is when working with the ",(0,o.kt)("inlineCode",{parentName:"p"},"AutoFilter")," which will cause rows to be ",(0,o.kt)("inlineCode",{parentName:"p"},"Hidden"),". You can get a ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," that contains all of the visible rows which is the same as the rows which satisfy the filter. If your data is well structured or can be filtered, this ends up being a great way to push the burden of filtering onto Excel instead of having all that logic in VBA."),(0,o.kt)("p",null,"You can also use ",(0,o.kt)("inlineCode",{parentName:"p"},"SpecialCells")," to quickly return a list of those cells which have a value (or formula) if you have a large block of sparse data. Once you have all of those cells, you can ",(0,o.kt)("inlineCode",{parentName:"p"},"Intersect()")," the ",(0,o.kt)("inlineCode",{parentName:"p"},"EntireColumn")," (or row) with the header of the data. This allows you to move quickly through data without having to build addresses or remember where specific things are. In general, this highlights an important strategy: if you can obtain ",(0,o.kt)("inlineCode",{parentName:"p"},"Ranges")," with the areas that are critical, you can quickly manipulate those ",(0,o.kt)("inlineCode",{parentName:"p"},"Ranges")," to perform some action. You can spend less time building finding cells and ",(0,o.kt)("inlineCode",{parentName:"p"},"Ranges")," once you know how to work and combine these functions."),(0,o.kt)("p",null,"TODO: add the table manipulation code here to give an example of that"),(0,o.kt)("p",null,"TODO: consider adding an example of using SpecialCells with filtering"),(0,o.kt)("h3",{id:"working-with-a-range-via-union-and-intersect"},"working with a ",(0,o.kt)("inlineCode",{parentName:"h3"},"Range")," via ",(0,o.kt)("inlineCode",{parentName:"h3"},"Union")," and ",(0,o.kt)("inlineCode",{parentName:"h3"},"Intersect")),(0,o.kt)("p",null,"You can perform set operations on multiple Ranges using Union and Intersect. Like all set operations, they correspond to different sections of a Venn Diagram. The simpler example is using ",(0,o.kt)("inlineCode",{parentName:"p"},"Union")," since it will always return a new valid Range if it was fed valid Ranges to start. It works by growing the Range into a new Range that includes all previous objects referenced."),(0,o.kt)("p",null,"Intersect is a different beast because it is possible for it to return ",(0,o.kt)("inlineCode",{parentName:"p"},"Nothing")," if the given Ranges do not actually intersect. This is actually a very useful property if you are trying to confirm whether or not a given cell is within in another Range."),(0,o.kt)("p",null,"TODO: add a picture of set operations"),(0,o.kt)("p",null,"Some common examples of where these functions come up:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Intersect is used with Events and other usability tasks to determine if a given or selected Cell is within a target Range"),(0,o.kt)("li",{parentName:"ul"},"Interacted is very useful with Offset and Resize to grab a new Range that contains a subset of data of the original Range without having to worry about creating a new Range that includes cells not previously included. IN this sense, Intersect only allows a Range to get smaller."),(0,o.kt)("li",{parentName:"ul"},'Union can be very helpful when building a larger group to change all of their properties at once. This is quite nice because Excel will "batch" the calculations if you change the ',(0,o.kt)("inlineCode",{parentName:"li"},"Value")," all at once. This sam technique can b used to build a Range to delete")),(0,o.kt)("p",null,"TODO: add Union-Delete example"),(0,o.kt)("p",null,"TODO: add Intersect example to remove headers"),(0,o.kt)("p",null,"TODO: add Intersect technique for Events and Selection changed"),(0,o.kt)("h3",{id:"the-kitchen-sink-of-remaining-range-ideas"},"the kitchen sink of remaining ",(0,o.kt)("inlineCode",{parentName:"h3"},"Range")," ideas"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Pull the ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," reference from some other object"),(0,o.kt)("li",{parentName:"ul"},"Name a cell and use that name indirectly -- ",(0,o.kt)("inlineCode",{parentName:"li"},'Names("CellName")')),(0,o.kt)("li",{parentName:"ul"},"Ask the user to select the ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," to use"),(0,o.kt)("li",{parentName:"ul"},"Use a function to get a reference -- ",(0,o.kt)("inlineCode",{parentName:"li"},"Application.Index")),(0,o.kt)("li",{parentName:"ul"},"Search for the cell based on its function or value -- ",(0,o.kt)("inlineCode",{parentName:"li"},"Find()")),(0,o.kt)("li",{parentName:"ul"},"Process a formula to determine the ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," it depends on")),(0,o.kt)("p",null,"TODO: look into the Trace functions to see what they return"),(0,o.kt)("h4",{id:"objects-that-will-return-a-range"},"Objects that will return a Range"),(0,o.kt)("p",null,"One of the greatest consistencies throughout VBA and the Object Model is how various objects will return a new object or reference to a useful property. At times, this can save you a large chunk of time trying to recreate that access from scratch. The key then is knowing when these properties exist and how to use them."),(0,o.kt)("p",null,"Below is a rough summary of objects that will give you access to a Range."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"TODO: create this list"),(0,o.kt)("li",{parentName:"ul"},"TODO: consider making this a cheat sheet or similar since it covers most of the sections in this chapter")),(0,o.kt)("p",null,"In addition to objects that will return a Range, there are also objects which will not return a Range but should. These include:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"TODO: create the rest of this list"),(0,o.kt)("li",{parentName:"ul"},"Chart Series info related to the Name, Values, and XValues. You are required to work through the ",(0,o.kt)("inlineCode",{parentName:"li"},"=SERIES")," formula instead")),(0,o.kt)("h4",{id:"using-namesreferstorange"},"Using ",(0,o.kt)("inlineCode",{parentName:"h4"},"Names().RefersToRange")),(0,o.kt)("p",null,"There are two ways to work with named ranges. One of them is quite simple: ",(0,o.kt)("inlineCode",{parentName:"p"},'Range("SomeNamedRange")'),". This works well in a couple of cases:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"You know the exact name you want to use or can prompt the user for it"),(0,o.kt)("li",{parentName:"ul"},"You are using the ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," call on an object that has proper scope.")),(0,o.kt)("p",null,"For the latter point, the default named ranges have ",(0,o.kt)("inlineCode",{parentName:"p"},"Workbook")," scope and the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," call works across the board. This becomes more of an issue when you are using the same name across multiple Worksheets with a Worksheet level scope. You can still access the named ranged, but now your call to ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),", needs to be ",(0,o.kt)("inlineCode",{parentName:"p"},"Worksheet.Range")," from the correctly scoped Worksheet."),(0,o.kt)("p",null,"The former point about needing to know the name is more often the problem. Sometimes you want to help someone use a named range, but you simply do not know what they are named. One trivial example is creating an addin that outputs all of the named ranges in the Workbook. You cannot iterate them through ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," because you want to know what they are!"),(0,o.kt)("p",null,"When you are in a position where you want to use the named ranges but do not know or want to use the actual names, you can go directly through the ",(0,o.kt)("inlineCode",{parentName:"p"},"Names")," object. There are two ways to do this:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Iterate the ",(0,o.kt)("inlineCode",{parentName:"li"},"Names")," with no knowledge of them"),(0,o.kt)("li",{parentName:"ul"},"Use an index, i.e. the ",(0,o.kt)("inlineCode",{parentName:"li"},"Name")," and call into ",(0,o.kt)("inlineCode",{parentName:"li"},"Names(index)"))),(0,o.kt)("p",null,"Once you have access to a valid ",(0,o.kt)("inlineCode",{parentName:"p"},"Name"),", you can then access the ",(0,o.kt)("inlineCode",{parentName:"p"},"RefersToRange")," which will return a Range that can be used. There are few instances where this is ever going to be better if you already have the name. The one exception to this is if you are wanting to change some of the metadata associated with the Name. This mainly includes the comment on the name since there is not much else. another option is that you can copy the named Range as a new range with a slightly different name. I have done this before to process all of the named ranges into some new named Range based on a formula which included the previous one. This can be a critical step to improving the performance of array formulas that previously pointed to entire columns. The problem is that create the dynamically named ranges is an absolute pain without VBA."),(0,o.kt)("p",null,"TODO: add an example of the dynamic name creation"),(0,o.kt)("p",null,"Once you are comfortable accessing named ranges, you may find that it is helpful to create them from time to time from VBA. This can be a helpful way of storing a complicated Range that your VBA created without having to select the cells and hope you can type the name correctly."),(0,o.kt)("h4",{id:"using-applicationinputbox-type8"},"Using ",(0,o.kt)("inlineCode",{parentName:"h4"},"Application.InputBox(, Type:=8)")),(0,o.kt)("p",null,"One very useful technique for obtaining a Range is to ask the user for one. This is one of the fastest ways to level up your VBA game because it provides the user control while also making your VBA look pretty slick with the Range picker. The other upside here is that the InputBox Range picker generally works better than the RedEdit version on a form. The odd thing here is two-fold:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"You have to know that InputBOx exists on the Application alone. IF you use the other version, then you cannot supply the Type"),(0,o.kt)("li",{parentName:"ul"},"You have to know that Type:=8 allows for a Range selection")),(0,o.kt)("p",null,"Once you have two those things down (because you read this book!) then you are able to ask the user to pick a Range with ease. The other very nice thing about the InputBox approach is that you can supply a default address (not Range) and it will automatically be selected at the start. I have used this approach to get effect in bUTL to allow the VBA to process the Selection (by default) or to allow the user to select something different. This is a very clean solution to snivel defaults while also allowing the user to do something different once they read your initial prompt. It is also dead simple to upgrade your current ",(0,o.kt)("inlineCode",{parentName:"p"},"Set rng = Range()")," to ",(0,o.kt)("inlineCode",{parentName:"p"},'Set rng = Application.InputBox("Select a cell", Type:=8)')," instead. For utility type code, the difference in immense in terms of not having to hard code or guess Ranges. Or you can still guess them but provide the user a chance to change the guess."),(0,o.kt)("p",null,"TODO: move that Function here form bUTL GetOrSelect..."),(0,o.kt)("h4",{id:"using-applicationindex"},"Using ",(0,o.kt)("inlineCode",{parentName:"h4"},"Application.Index")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"=INDEX")," formula is the most potent formula in Excel. Its counterpart in the VBA world is also powerful but less impressive compared to real programming. Having said that, the ",(0,o.kt)("inlineCode",{parentName:"p"},"Index")," function works exactly as expected in VBA and is a very nice tool to have if you are comfortable using INDEX in a normal spreadsheet. The real power of Index is that you can use it to replace a lot of the common code where you iterate through a Range until you find given value. One potential upside of Index is that you can upgrade an Excel only methodology over to VBA with minimal change to formulas. Once you have the work converted over, you can then set about addin the details that VBA alone can provide."),(0,o.kt)("p",null,"TODO: does this work any different than Cells? is it really that useful?"),(0,o.kt)("h4",{id:"using-rangefind"},"Using ",(0,o.kt)("inlineCode",{parentName:"h4"},"Range.Find()")),(0,o.kt)("p",null,"I seldom use ",(0,o.kt)("inlineCode",{parentName:"p"},"Range.Find()"),", but it can be a powerful addition when you know what you want to search for. My problem with .Find is that it is incredibly rare that I have some free text I am searching for and want to find using VBA. Generally speaking, Find becomes useful when you are processing a somewhat arbitrary Worksheet which may contain certain data you want. In my experience, I am far more likely to use an AutoFilter or something other than Find. Part of the problem for me is that I have never had a problem using some other method than Find. I also generally find myself somewhat confused by the parameters and the general execution of Find. Typically, you will need to create a While loop to search for the next found items."),(0,o.kt)("p",null,"I also have the (probably unfair) view that Find is a crutch to not being able to use other methods to Find a given Range. I generally prefer to iterate through cells and check values. My mind is built around building a Range and processing it rather than attempting to find a Range and then process it. Your mileage may vary."),(0,o.kt)("p",null,"TODO: add an example of using Find correctly"),(0,o.kt)("h4",{id:"pulling-a-range-from-a-formula-with-string-processing"},"Pulling a Range from a Formula with string processing"),(0,o.kt)("p",null,"One of the next level things to do with VBA is to start processing your Formulas to drive your VBA. There are a couple of places where this might be useful:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"You are dealing with a Chart Series Formula which must be parsed"),(0,o.kt)("li",{parentName:"ul"},"You want to Trace the precedent cells but don't want to deal with TracePrecedents"),(0,o.kt)("li",{parentName:"ul"},"You want to modify some part of the formula (e.g. take ",(0,o.kt)("inlineCode",{parentName:"li"},"A1")," and surround it with an ",(0,o.kt)("inlineCode",{parentName:"li"},"ABS(A1)"),")"),(0,o.kt)("li",{parentName:"ul"},"You want to make all of the cells in a specific formula a specific color (like a permanent version of hitting ",(0,o.kt)("inlineCode",{parentName:"li"},"F2"),")")),(0,o.kt)("p",null,"Whatever your motivation, it's good to remember that the formulas in a spreadsheet are generally the most important information aside from the actual data. IN some spreadsheets, the formulas are the only important part. If you want to extract and use this information, then it is helpful to be able to parse the formulas and identify the Ranges."),(0,o.kt)("p",null,"There are a couple of approaches to parsing Ranges from formulas, depending on what you need to do and what you start with:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Your formulas contain only A1 style references without sheet names"),(0,o.kt)("li",{parentName:"ul"},"Your formulas may contain a sheet name too"),(0,o.kt)("li",{parentName:"ul"},"You want to extract non-range formula information")),(0,o.kt)("p",null,"For the first two, you can build relatively simple parsers which can extract the Range information which good accuracy. The key here is to understand exactly what your formulas look like. The worst case is having to build a full out formulas parser which is a non-trivial exercise. Handling all possible Excel syntaxes is a mess."),(0,o.kt)("p",null,"If you can settle for something less, then you have a couple of approaches at hand:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Use a Regular Expression keyed in to Range options"),(0,o.kt)("li",{parentName:"ul"},"Use your knowledge of the possible formulas to extract the relevant parts with string functions")),(0,o.kt)("p",null,"TODO: add an example of some Regex which work here... expanding complexity"),(0,o.kt)("p",null,"TODO: add an example of parsing out with Split and Left or something"),(0,o.kt)("h3",{id:"working-with-ranges-via-advanced-techniques"},"working with ",(0,o.kt)("inlineCode",{parentName:"h3"},"Ranges")," via advanced techniques"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Use the Offset-Intersect technique to get a block of data without its header"),(0,o.kt)("li",{parentName:"ul"},"Use the ",(0,o.kt)("inlineCode",{parentName:"li"},"AutoFilter")," to filter a data set and then get the visible cells with ",(0,o.kt)("inlineCode",{parentName:"li"},"SpecialCells()")),(0,o.kt)("li",{parentName:"ul"},"Use one of the techniques above to get a ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," on one ",(0,o.kt)("inlineCode",{parentName:"li"},"Worksheet"),"; grab the corresponding ",(0,o.kt)("inlineCode",{parentName:"li"},"Range")," on a another ",(0,o.kt)("inlineCode",{parentName:"li"},"Worksheet")," to do some processing")),(0,o.kt)("h4",{id:"offset-intersect"},"Offset-Intersect"),(0,o.kt)("p",null,'The Offset-Intersect is one of the most useful and simple approaches to creating a Range. The idea is that by using Intersect, you will avoid ever creating a Range that is bigger than some starting point. This means that you will not be able to accidentally add a blank or neighboring column to your Range. Knowing this, you can then take whatever steps are necessary to "remove" bad sections from our Range. This is most commonly used to remove a header row from the top of a Range. If you are using Offset, the only rule is that you must make a valid move before calling Intersect. To remove a header, assuming you have a range which is a block of data with headers, simply do: ',(0,o.kt)("inlineCode",{parentName:"p"},"Set rng = Intersect(rng, rng.Offset(1))"),". This gives you a new Range which has all of the cells of the first one except for the first row."),(0,o.kt)("p",null,"TODO: add an image of how this works"),(0,o.kt)("p",null,"Intersect used in this fashion is incredibly powerful. You can do all sorts of wacky steps to filter out a Range and then Intersect against the original Range to ensure that you have not accidentally stepped outside your starting box."),(0,o.kt)("h4",{id:"autofilter-and-then-specialcells"},"AutoFilter and then SpecialCells"),(0,o.kt)("p",null,"This approach is straight forward and mirrors a common operation in non VBA Excel. You use an AutoFilter to filter out specific cells and then you can select only the visible cells. In Excel, you can use ",(0,o.kt)("inlineCode",{parentName:"p"},"ALT+SEMICOLON")," to only select visible cells. Often times, you will not need to actually do this since Excel tries to help you when dealing with Hidden rows and columns. Typically Excel will not apply formatting to hidden cells and will also not fill a formula through them (assuming you used the Fill command)."),(0,o.kt)("p",null,"In VBA, things are often more difficult because you are working with the underlying Range independent of whether or not the cells are hidden. To get around this, Excel provides the SpecialCells function which allows you to select a subset of cells based on some criteria. when using the AutoFilter, the most common criterion to use is that of visibility. You can call ",(0,o.kt)("inlineCode",{parentName:"p"},"Range.SpecialCells(xlCellTypeVisible)")," to obtain a new Range which only contains visible cells."),(0,o.kt)("p",null,"If you have ever written a loop which does a ",(0,o.kt)("inlineCode",{parentName:"p"},"If rng.Hidden = True Then...")," then you will be grateful to know that Excel VBA provides this feature automatically. SpecialCells really is one of the most powerful ways to access Ranges in an intuitive fashion that matches normal Excel."),(0,o.kt)("h4",{id:"the-duplicated-range-on-another-sheet"},"The Duplicated Range on another Sheet"),(0,o.kt)("p",null,"If you are working with multiple sheets that are the same, similar, or related, you will often find yourself using information about one sheet to build a Range on another or several others. THe problem with Ranges however is that they are not allowed to span multiple Worksheets. This means that if you want to apply some action to each ",(0,o.kt)("inlineCode",{parentName:"p"},"A1:A10")," Range on each Worksheet, you will need to do it iteratively. This can be a pain however if you built your Range using code and not a direct address. To get around this, you can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"Range.Address()")," function to obtain an address for the Range. The trick here is to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"Address")," function without parameters which will give you the local address without a Worksheet name. Y ou can then use that address on each of the other Worksheets, you access the given cells on that Worksheet."),(0,o.kt)("p",null,"This is a nice way to replicate the functionality of Excel where you can select multiple Worksheets with CTRL or SHIFT and then apply some action to all of them. The really nice thing about VBA however is that you can apply an action that is aware of the Worksheet on which it is acting. This si quite nice because the normal multi edit feature do the exact same steps to all spreadsheets whereas you may want to use ",(0,o.kt)("inlineCode",{parentName:"p"},"End")," or something in your code."),(0,o.kt)("h3",{id:"range-via-user-input-inputbox"},"Range via user input: InputBox"),(0,o.kt)("p",null,"This section will focus on obtaining a Range from user input via the Application.InputBox"),(0,o.kt)("p",null,"TODO: clean up this code"),(0,o.kt)("h4",{id:"getinputorselectionmd"},"GetInputOrSelection.md"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-vb"},"Public Function GetInputOrSelection(ByVal userPrompt As String) As Range\n\n    Dim defaultString As String\n\n    If TypeOf Selection Is Range Then\n        defaultString = Selection.Address\n    End If\n\n    On Error GoTo ErrorNoSelection\n    Set GetInputOrSelection = Application.InputBox(userPrompt, Type:=8, Default:=defaultString)\n\n    Exit Function\n\nErrorNoSelection:\n    Set GetInputOrSelection = Nothing\n\nEnd Function\n")))}p.isMDXComponent=!0}}]);